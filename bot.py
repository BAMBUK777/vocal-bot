code = """#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# –ß–ê–°–¢–¨ 1 ‚Äî –ò–ú–ü–û–†–¢–´ –ò –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø

import os
import json
import csv
import logging
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
from datetime import datetime, timedelta, date
from zoneinfo import ZoneInfo

import telebot
from telebot import types

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
PORT = int(os.getenv("PORT", "9999"))  # health-check –ø–æ—Ä—Ç –¥–ª—è Render
DATA_DIR = "data"
LANG_FILE = os.path.join(DATA_DIR, "lang.json")
SCHEDULE_FILE = os.path.join(DATA_DIR, "schedule.json")
TRANSFERS_FILE = os.path.join(DATA_DIR, "transfers.json")
RECORDS_FILE = os.path.join(DATA_DIR, "records.csv")
FEEDBACK_FILE = os.path.join(DATA_DIR, "feedback.csv")
LOG_FILE = os.path.join(DATA_DIR, "bot.log")
TZ = ZoneInfo("Asia/Tbilisi")

ADMINS = {
    7758773154: "joolay_vocal",
    388183067: "joolay_joolay"
}

TEACHERS = {
    "–Æ–ª—è": {"wd": [1,2,3,4], "hours": [f"{h}:00" for h in range(15,21)]},
    "–¢–æ—Ä–Ω–∏–∫–µ": {"wd": [5,6,0], "hours": [f"{h}:00" for h in range(8,23)]},
}

WD_SHORT = {0: "–ø–Ω", 1: "–≤—Ç", 2: "—Å—Ä", 3: "—á—Ç", 4: "–ø—Ç", 5: "—Å–±", 6: "–≤—Å"}

LANGUAGES = ["ru", "en", "ka"]
LANG_NAMES = {"ru": "–†—É—Å—Å–∫–∏–π üá∑üá∫", "en": "English üá¨üáß", "ka": "·É•·Éê·É†·Éó·É£·Éö·Éò üá¨üá™"}
DEFAULT_LANG = "ru"

MESSAGES = {
    "ru": {
        "choose_lang": "üëã –ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
        "lang_set":    "–Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {lang}",
        "main_menu":   "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        "btn_book":    "üìÜ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è",
        "btn_my":      "üëÅ –ú–æ—è –∑–∞–ø–∏—Å—å",
        "btn_transfer":"üîÑ –ü–µ—Ä–µ–Ω–µ—Å—Ç–∏",
        "btn_cancel":  "‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å",
        "btn_help":    "/help",
        "btn_admin":   "‚öôÔ∏è –ê–¥–º–∏–Ω–∫–∞",
        "cancel_q":    "‚ùó –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å?",
        "cancel_ok":   "‚úÖ –í–∞—à–∞ –∑–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞.",
        "no_booking":  "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π.",
        "pending":     "‚è≥ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.",
        "confirmed":   "‚úÖ –í–∞—à–∞ –∑–∞–ø–∏—Å—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞: {teacher} {date} {time}",
        "admin_notify":"üÜï –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞: {teacher} {date} {time}\\nüë§ {name} (ID:{uid})",
        "rem_before":  "üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞ —É—Ä–æ–∫ —É {teacher} –≤ {date} {time}",
        "feedback_req":"üìù –û—Ü–µ–Ω–∏—Ç–µ —É—Ä–æ–∫ —É {teacher} {date} {time} –æ—Ç 1 –¥–æ 5 –∑–≤—ë–∑–¥:",
        "ask_comment": "‚úçÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–π –æ—Ç–∑—ã–≤:",
        "thanks_fb":   "üôè –°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∑—ã–≤!",
        "transfer_q":  "‚ùó –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –∑–∞–ø–∏—Å—å?",
        "admin_tr":    "üîÅ –ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–µ—Ä–µ–Ω–æ—Å: {t} {d} {h} ‚Üí {nt} {nd} {nh}\\nüë§ {name} (ID:{uid})",
        "no_pending":  "–ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –∑–∞—è–≤–æ–∫."
    },
    "en": {
        # –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è English
    },
    "ka": {
        # –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è ·É•·Éê·É†·Éó·É£·Éö·Éò
    }
}
"""
print(code)

if __name__=="__main__":
    bot.infinity_polling(timeout=60,long_polling_timeout=60,skip_pending=True)
snippet = """# –ß–ê–°–¢–¨ 2 ‚Äî –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –§–ê–ô–õ–û–í, –õ–û–ì–ò–†–û–í–ê–ù–ò–ï, HEALTHCHECK, BOT INIT, –£–¢–ò–õ–ò–¢–´

# –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É data
os.makedirs(DATA_DIR, exist_ok=True)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è JSON-—Ñ–∞–π–ª–æ–≤, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
def ensure_json(path):
    if not os.path.exists(path):
        with open(path, 'w', encoding='utf-8') as f:
            json.dump({}, f, ensure_ascii=False, indent=2)

for path in [LANG_FILE, SCHEDULE_FILE, TRANSFERS_FILE]:
    ensure_json(path)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è CSV-—Ñ–∞–π–ª–æ–≤ —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏
def ensure_csv(path, headers):
    if not os.path.exists(path):
        with open(path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(headers)

ensure_csv(RECORDS_FILE, ['ts','teacher','date','time','uid','name','status'])
ensure_csv(FEEDBACK_FILE,['ts','teacher','date','time','uid','stars','text','approved'])

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    filename=LOG_FILE,
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s'
)

# –ó–∞–ø—É—Å–∫ health-check —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É PORT
class HC(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"OK")

threading.Thread(
    target=lambda: HTTPServer(("0.0.0.0", PORT), HC).serve_forever(),
    daemon=True
).start()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = telebot.TeleBot(os.getenv("BOT_TOKEN"))
bot.remove_webhook()

# –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å JSON
def load_json(path):
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_json(path, data):
    with open(path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

# –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —è–∑—ã–∫–æ–º
def get_lang(uid):
    langs = load_json(LANG_FILE)
    return langs.get(str(uid), DEFAULT_LANG)

def set_lang(uid, code):
    langs = load_json(LANG_FILE)
    langs[str(uid)] = code
    save_json(LANG_FILE, langs)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
def txt(uid, key, **kwargs):
    return MESSAGES[get_lang(uid)][key].format(**kwargs)
"""
snippet = '''# –ß–ê–°–¢–¨ 3 ‚Äî HANDLERS: —Å—Ç–∞—Ä—Ç, –≤—ã–±–æ—Ä —è–∑—ã–∫–∞, –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é, flow –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ—Ç–º–µ–Ω—ã

# –°–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
SESS = {}

# 1) /start –∏ /help ‚Äî –Ω–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã
@bot.message_handler(commands=["start", "help"])
def h_start(m):
    uid = m.from_user.id
    # —Å–±—Ä–æ—Å —è–∑—ã–∫–∞ ‚Äî –ø–æ–∫–∞–∂–µ–º –≤—ã–±–æ—Ä –∑–∞–Ω–æ–≤–æ
    langs = load_json(LANG_FILE)
    langs.pop(str(uid), None)
    save_json(LANG_FILE, langs)
    # –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤—ã–±—Ä–∞—Ç—å —è–∑—ã–∫
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for code in LANGUAGES:
        kb.add(LANG_NAMES[code])
    bot.send_message(uid, MESSAGES["ru"]["choose_lang"], reply_markup=kb)

# 2) –í—ã–±–æ—Ä —è–∑—ã–∫–∞ –∏–∑ –∫–Ω–æ–ø–æ–∫
@bot.message_handler(func=lambda m: m.text in LANG_NAMES.values())
def h_lang(m):
    uid = m.from_user.id
    # –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–¥ —è–∑—ã–∫–∞
    code = next(k for k,v in LANG_NAMES.items() if v == m.text)
    set_lang(uid, code)
    # –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    bot.send_message(uid, txt(uid, "lang_set", lang=m.text), reply_markup=kb_main(uid))

# 3) –ö–Ω–æ–ø–∫–∞ "–ó–∞–ø–∏—Å–∞—Ç—å—Å—è" ‚Äî –Ω–∞—á–∞–ª–æ flow –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
@bot.message_handler(func=lambda m: m.text == txt(m.from_user.id, "btn_book"))
def h_book(m):
    uid = m.from_user.id
    kb = types.InlineKeyboardMarkup()
    for tch in TEACHERS:
        kb.add(types.InlineKeyboardButton(tch, callback_data=f"t|{tch}"))
    bot.send_message(uid, txt(uid, "btn_book"), reply_markup=kb)

# 4) –û–±—Ä–∞–±–æ—Ç–∫–∞ callback-–æ–≤ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
@bot.callback_query_handler(lambda c: c.data.startswith("t|"))
def h_choose_teacher(c):
    uid = c.from_user.id
    tch = c.data.split("|",1)[1]
    SESS[uid] = {"t": tch}
    # –≤—ã–±–æ—Ä –Ω–µ–¥–µ–ª–∏
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–≠—Ç–∞ –Ω–µ–¥–µ–ª—è", callback_data="w|0"))
    kb.add(types.InlineKeyboardButton("–°–ª–µ–¥. –Ω–µ–¥–µ–ª—è", callback_data="w|1"))
    kb.add(types.InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="main"))
    bot.edit_message_text(f"{tch}: {txt(uid, 'choose_week')}", uid, c.message.message_id, reply_markup=kb)

@bot.callback_query_handler(lambda c: c.data.startswith("w|"))
def h_choose_week(c):
    uid = c.from_user.id
    wk = int(c.data.split("|",1)[1])
    tch = SESS[uid]["t"]
    SESS[uid]["wk"] = wk
    today = date.today()
    mon = today - timedelta(days=today.weekday()) + timedelta(weeks=wk)
    kb = types.InlineKeyboardMarkup(row_width=3)
    for i in range(7):
        d = mon + timedelta(days=i)
        if d >= today and d.weekday() in TEACHERS[tch]["wd"]:
            label = f"{d.strftime('%d.%m.%y')} ({WD_SHORT[d.weekday()]})"
            kb.add(types.InlineKeyboardButton(label, callback_data=f"d|{d.isoformat()}"))
    kb.add(types.InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="main"))
    bot.edit_message_text(txt(uid, "choose_day"), uid, c.message.message_id, reply_markup=kb)

@bot.callback_query_handler(lambda c: c.data.startswith("d|"))
def h_choose_day(c):
    uid = c.from_user.id
    d = c.data.split("|",1)[1]
    tch = SESS[uid]["t"]
    SESS[uid]["d"] = d
    sch = load_json(SCHEDULE_FILE).get(tch, {}).get(d, {})
    kb = types.InlineKeyboardMarkup(row_width=2)
    for h in TEACHERS[tch]["hours"]:
        if h not in sch:
            kb.add(types.InlineKeyboardButton(h, callback_data=f"h|{h}"))
    kb.add(types.InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="main"))
    bot.edit_message_text(txt(uid, "choose_time"), uid, c.message.message_id, reply_markup=kb)

@bot.callback_query_handler(lambda c: c.data.startswith("h|"))
def h_choose_hour(c):
    uid = c.from_user.id
    h = c.data.split("|",1)[1]
    SESS[uid]["h"] = h
    bot.send_message(uid, "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –¥–ª—è –∑–∞–ø–∏—Å–∏:", reply_markup=types.ReplyKeyboardRemove())
    bot.register_next_step_handler_by_chat_id(uid, finish_booking)

# 5) –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
def finish_booking(m):
    uid = m.chat.id
    name = m.text.strip()
    tch = SESS[uid]["t"]
    d   = SESS[uid]["d"]
    h   = SESS[uid]["h"]
    sch = load_json(SCHEDULE_FILE)
    sch.setdefault(tch, {}).setdefault(d, {})[h] = {"uid":uid, "name":name, "status":"pending"}
    save_json(SCHEDULE_FILE, sch)
    with open(RECORDS_FILE, "a", newline="", encoding="utf-8") as f:
        csv.writer(f).writerow([datetime.now(TZ).isoformat(), tch, d, h, uid, name, "pending"])
    bot.send_message(uid, txt(uid, "pending"), reply_markup=kb_main(uid))
    for aid in ADMINS:
        kb = types.InlineKeyboardMarkup()
        kb.add(types.InlineKeyboardButton("‚úÖ", callback_data=f"conf|{tch}|{d}|{h}"))
        kb.add(types.InlineKeyboardButton("‚ùå", callback_data=f"rej|{tch}|{d}|{h}"))
        bot.send_message(aid, txt(uid, "admin_notify", teacher=tch, date=d, time=h, name=name, uid=uid), reply_markup=kb)
    del SESS[uid]

# 6) –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–º–µ–Ω—ã –∑–∞–ø–∏—Å–∏
@bot.message_handler(func=lambda m: m.text == txt(m.from_user.id, "btn_cancel"))
def h_cancel(m):
    uid = m.from_user.id
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("‚úÖ", callback_data="cnf|yes"))
    kb.add(types.InlineKeyboardButton("‚ùå", callback_data="cnf|no"))
    bot.send_message(uid, txt(uid, "cancel_q"), reply_markup=kb)

@bot.callback_query_handler(lambda c: c.data.startswith("cnf|"))
def h_cancel_confirm(c):
    uid = c.from_user.id
    ans = c.data.split("|",1)[1]
    if ans == "yes":
        sch = load_json(SCHEDULE_FILE)
        for tch in list(sch):
            for d in list(sch[tch]):
                for h, info in list(sch[tch][d].items()):
                    if info["uid"] == uid:
                        del sch[tch][d][h]
                        save_json(SCHEDULE_FILE, sch)
                        bot.send_message(uid, txt(uid, "cancel_ok"), reply_markup=kb_main(uid))
                        return
        bot.send_message(uid, txt(uid, "no_booking"), reply_markup=kb_main(uid))
    else:
        bot.send_message(uid, txt(uid, "main_menu"), reply_markup=kb_main(uid))
'''
code = r"""# –ß–ê–°–¢–¨ 4 ‚Äî –ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï, –ü–ï–†–ï–ù–û–°, –ú–û–ò –ó–ê–ü–ò–°–ò, –ê–î–ú–ò–ù-–ü–ê–ù–ï–õ–¨

# 7) –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ/–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –∞–¥–º–∏–Ω–æ–º
@bot.callback_query_handler(lambda c: c.data.startswith(("conf|", "rej|")))
def h_admin_confirm(c):
    uid = c.from_user.id
    action, tch, d, h = c.data.split("|")
    sch = load_json(SCHEDULE_FILE)
    info = sch[tch][d][h]
    if action == "conf":
        info["status"] = "confirmed"
        save_json(SCHEDULE_FILE, sch)
        bot.answer_callback_query(c.id, "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ")
        bot.send_message(info["uid"], txt(info["uid"], "confirmed",
                         teacher=tch, date=d, time=h), reply_markup=kb_main(info["uid"]))
    else:
        del sch[tch][d][h]
        save_json(SCHEDULE_FILE, sch)
        bot.answer_callback_query(c.id, "–û—Ç–∫–ª–æ–Ω–µ–Ω–æ")
        bot.send_message(info["uid"], txt(info["uid"], "cancel_ok"),
                         reply_markup=kb_main(info["uid"]))

# 8) –ü–µ—Ä–µ–Ω–æ—Å –∑–∞–ø–∏—Å–∏
@bot.message_handler(func=lambda m: m.text == txt(m.from_user.id, "btn_transfer"))
def h_transfer(m):
    uid = m.from_user.id
    sch = load_json(SCHEDULE_FILE)
    for tch in sch:
        for d in sch[tch]:
            for h, info in sch[tch][d].items():
                if info["uid"] == uid:
                    SESS[uid] = {"old": (tch, d, h)}
                    kb = types.InlineKeyboardMarkup()
                    kb.add(types.InlineKeyboardButton("‚úÖ", callback_data="tr|yes"),
                           types.InlineKeyboardButton("‚ùå", callback_data="tr|no"))
                    bot.send_message(uid, txt(uid, "transfer_q"), reply_markup=kb)
                    return
    bot.send_message(uid, txt(uid, "no_booking"), reply_markup=kb_main(uid))

@bot.callback_query_handler(lambda c: c.data.startswith("tr|"))
def h_transfer_confirm(c):
    uid = c.from_user.id
    ans = c.data.split("|")[1]
    if ans == "yes":
        # –∑–∞–ø—É—Å–∫–∞–µ–º flow –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–Ω–æ–≤–æ
        h_book(c.message)
    else:
        bot.answer_callback_query(c.id, "–û—Ç–º–µ–Ω–∞")

# 9) –ú–æ–∏ –∑–∞–ø–∏—Å–∏
@bot.message_handler(func=lambda m: m.text == txt(m.from_user.id, "btn_my"))
def h_my(m):
    uid = m.from_user.id
    sch = load_json(SCHEDULE_FILE)
    lines = []
    for tch in sch:
        for d in sch[tch]:
            for h, info in sch[tch][d].items():
                if info["uid"] == uid:
                    lines.append(f"{tch} {d} {h} ({info['status']})")
    bot.send_message(uid, "\n".join(lines) or txt(uid, "no_booking"),
                     reply_markup=kb_main(uid))

# 10) –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
@bot.message_handler(func=lambda m: m.text == txt(m.from_user.id, "btn_admin") and m.from_user.id in ADMINS)
def h_admin_panel(m):
    uid = m.from_user.id
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.add(types.InlineKeyboardButton("üìã –ó–∞–ø–∏—Å–∏", callback_data="ad|book"),
           types.InlineKeyboardButton("‚úçÔ∏è –û—Ç–∑—ã–≤—ã", callback_data="ad|fb"),
           types.InlineKeyboardButton("üîÅ –ü–µ—Ä–µ–Ω–æ—Å—ã", callback_data="ad|tr"))
    bot.send_message(uid, txt(uid, "main_menu"), reply_markup=kb)

@bot.callback_query_handler(lambda c: c.data.startswith("ad|"))
def h_admin_router(c):
    uid = c.from_user.id
    cmd = c.data.split("|")[1]
    if cmd == "book":
        sch = load_json(SCHEDULE_FILE)
        text = "–í—Å–µ –∑–∞–ø–∏—Å–∏:\n"
        for tch in sch:
            for d in sch[tch]:
                for h, info in sch[tch][d].items():
                    text += f"{tch} {d} {h} ‚Äî {info['name']} ({info['status']})\n"
        c.message.edit_text(text or "–ü—É—Å—Ç–æ")
    elif cmd == "fb":
        fb = []
        with open(FEEDBACK_FILE, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for r in reader:
                fb.append(f"{r['date']} {r['time']} {r['teacher']} ‚Äî {r['stars']}‚òÖ {r['text']}")
        c.message.edit_text("\n".join(fb) or "–ù–µ—Ç –æ—Ç–∑—ã–≤–æ–≤")
    elif cmd == "tr":
        tr = load_json(TRANSFERS_FILE)
        text = "–ü–µ—Ä–µ–Ω–æ—Å—ã:\n"
        for uid_k, data in tr.items():
            text += f"{data['old']} ‚Üí {data['new']} (ID {uid_k})\n"
        c.message.edit_text(text or "–ù–µ—Ç –ø–µ—Ä–µ–Ω–æ—Å–æ–≤")
"""
# –ß–ê–°–¢–¨ 5 ‚Äî –ù–ê–ü–û–ú–ò–ù–ê–ù–ò–Ø, –û–ë–†–ê–¢–ù–ê–Ø –°–í–Ø–ó–¨ –ò –ê–í–¢–û-–û–ß–ò–°–¢–ö–ê

# 11) –§–æ–Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π, –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –æ—Ç–∑—ã–≤–æ–≤ –∏ –æ—á–∏—Å—Ç–∫–∏ —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π
def task_loop():
    while True:
        now = datetime.now(TZ)
        sch = load_json(SCHEDULE_FILE)
        changed = False

        # –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ –∑–∞–ø—Ä–æ—Å—ã –æ—Ç–∑—ã–≤–æ–≤
        for tch, days in sch.items():
            for d, hours in days.items():
                lesson_date = datetime.fromisoformat(d + "T00:00:00").replace(tzinfo=TZ)
                for h, info in list(hours.items()):
                    lesson_dt = lesson_date + timedelta(
                        hours=int(h.split(":")[0]),
                        minutes=int(h.split(":")[1])
                    )
                    delta = (lesson_dt - now).total_seconds()

                    # –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∑–∞ 2 —á–∞—Å–∞
                    if 0 < delta <= 7200 and info["status"] == "confirmed":
                        bot.send_message(
                            info["uid"],
                            txt(info["uid"], "rem_before", teacher=tch, date=d, time=h)
                        )
                        info["status"] = "reminded"
                        changed = True

                    # –ó–∞–ø—Ä–æ—Å –æ—Ç–∑—ã–≤–∞ —á–µ—Ä–µ–∑ 30 –º–∏–Ω—É—Ç –ø–æ—Å–ª–µ —É—Ä–æ–∫–∞
                    if -1800 <= delta < 0 and info["status"] == "reminded":
                        kb = types.InlineKeyboardMarkup(row_width=5)
                        for stars in range(1, 6):
                            kb.add(types.InlineKeyboardButton(
                                f"{stars}‚òÖ",
                                callback_data=f"fb|{tch}|{d}|{h}|{stars}"
                            ))
                        bot.send_message(
                            info["uid"],
                            txt(info["uid"], "feedback_req", teacher=tch, date=d, time=h),
                            reply_markup=kb
                        )
                        info["status"] = "feedback_pending"
                        changed = True

        # –ê–≤—Ç–æ-–æ—á–∏—Å—Ç–∫–∞ –∑–∞–ø–∏—Å–µ–π —Å—Ç–∞—Ä—à–µ –¥–≤—É—Ö –Ω–µ–¥–µ–ª—å
        cutoff = date.today() - timedelta(days=14)
        for tch in list(sch):
            for d in list(sch[tch]):
                if datetime.fromisoformat(d + "T00:00:00").date() < cutoff:
                    del sch[tch][d]
                    changed = True
            if not sch[tch]:
                del sch[tch]
                changed = True

        if changed:
            save_json(SCHEDULE_FILE, sch)

        threading.Event().wait(3600)  # –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Ä–∞–∑ –≤ —á–∞—Å

threading.Thread(target=task_loop, daemon=True).start()


# 12) –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–π—Ç–∏–Ω–≥–∞ –æ—Ç–∑—ã–≤–∞
@bot.callback_query_handler(lambda c: c.data.startswith("fb|"))
def h_feedback_rating(c):
    c.answer()
    uid = c.from_user.id
    _, tch, d, h, stars = c.data.split("|")
    SESS[uid] = {"tch": tch, "date": d, "time": h, "stars": int(stars)}
    bot.send_message(uid, txt(uid, "ask_comment"), reply_markup=types.ReplyKeyboardRemove())
    bot.register_next_step_handler(
        bot.send_message(uid, "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:"),
        h_feedback_comment
    )

def h_feedback_comment(m):
    uid = m.chat.id
    data = SESS.pop(uid)
    comment = m.text.strip()
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ CSV
    with open(FEEDBACK_FILE, "a", newline="", encoding="utf-8") as f:
        csv.writer(f).writerow([
            datetime.now(TZ).isoformat(),
            data["tch"], data["date"], data["time"],
            uid, data["stars"], comment,
            "approved" if data["stars"] == 5 else "pending"
        ])
    bot.send_message(uid, txt(uid, "thanks_fb"), reply_markup=kb_main(uid))
    # –£–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–æ–≤ –æ –Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–º –æ—Ç–∑—ã–≤–µ
    if data["stars"] < 5:
        for aid in ADMINS:
            kb = types.InlineKeyboardMarkup()
            kb.add(types.InlineKeyboardButton(
                "‚úÖ –û–¥–æ–±—Ä–∏—Ç—å",
                callback_data=f"appr|{m.chat.id}"
            ))
            bot.send_message(
                aid,
                f"–ù–æ–≤—ã–π –æ—Ç–∑—ã–≤ –æ—Ç {uid}: {data['stars']}‚òÖ {comment}",
                reply_markup=kb
            )

# 13) –ú–æ–¥–µ—Ä–∞—Ü–∏—è –æ—Ç–∑—ã–≤–æ–≤ –∞–¥–º–∏–Ω–æ–º
@bot.callback_query_handler(lambda c: c.data.startswith("appr|"))
def h_approve_feedback(c):
    _, uid_str = c.data.split("|")
    target_uid = int(uid_str)
    rows = []
    with open(FEEDBACK_FILE, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for r in reader:
            if int(r["uid"]) == target_uid and r["approved"] == "pending":
                r["approved"] = "approved"
            rows.append(r)
    with open(FEEDBACK_FILE, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=reader.fieldnames)
        writer.writeheader()
        writer.writerows(rows)
    c.answer("–û—Ç–∑—ã–≤ –æ–¥–æ–±—Ä–µ–Ω.")
